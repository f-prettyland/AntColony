
-------------
Different parallelisations:
-------------
	-ants
		better with larger graphs where explore less?
	-probablity of edge
		should be better with smaller
		should be broken down per node as need sum of all vals to do
	-phermonal calc update


-------------
Compare:
-------------
	- different start location should have no diff
	- using private constant to global const
		//eeehh, maybe to show off understandinf of openCL


-------------
Discuss ants:
-------------
	- not using the cost array effectively, recalcing all of this so many times (well depending on k)

	

	- Use of boolean array to represent visited nodes, since need to visit all and need to look up often is much faster
		does this affect memory? How much?
		there is code in APPEND if wanna use

	- Calc edgeAttraction 
		Counting how many used
			Should realloc just to needed nodes? Currently just ignores final x elements
			Also need second array to map what element means what node
		OTHER OPTION:
			Calc all and leave them with scores of 0... This means more iterations of simple maths
		
	Calculate values and sum whilst going through, only use sum in finding of probable edge and means you don't have to divide by sum immmediately after, instead only done when needed

	Randomness
		Using Xorshift
		https://stackoverflow.com/questions/9912143/how-to-get-a-random-number-in-opencl


-------------
Discuss generic:
-------------
	This is an undirected graph, it _should_ have triangular array.
		Requires much more searching? NO, just more accessing?

	Lets assume graph is COMPLETE
		assume no zero cost edges (these are used to show inability to cross)

	Need to beat O(n!) complexity to be better than all permutations



-------------
TODO
-------------
	When searching prev nodes use hash set

	Conditional path taking using PCG as random generator
		\cite{neill}
		http://www.pcg-random.org/paper.html

	apply mutation to avoid local loop
		http://link.springer.com/chapter/10.1007/3-540-45724-0_20
	Other variants
		http://www.codeproject.com/Articles/644067/Applying-Ant-Colony-Optimization-Algorithms-to-Sol




-------------
APPEND
-------------
		
//using shitty visitin list
bool hasSeen(int* visited, int possVisit){
	for (int i = 0; i < numNodes; ++i)
	{
		if(visited[i]== possVisit){
			return true;
		}
	}
	return false;
}
